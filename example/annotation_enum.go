// Code generated by go-enum DO NOT EDIT.
// Version: example
// Revision: example
// Build Date: example
// Built By: example

//go:build example
// +build example

package example

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strings"
)

const (
	// AnnotationRed is a AnnotationColor of type annotation_red.
	AnnotationRed AnnotationColor = "annotation_red"
	// AnnotationGreen is a AnnotationColor of type annotation_green.
	AnnotationGreen AnnotationColor = "annotation_green"
	// AnnotationBlue is a AnnotationColor of type annotation_blue.
	AnnotationBlue AnnotationColor = "annotation_blue"
)

var ErrInvalidAnnotationColor = errors.New("not a valid AnnotationColor")

// String implements the Stringer interface.
func (x AnnotationColor) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AnnotationColor) IsValid() bool {
	_, err := ParseAnnotationColor(string(x))
	return err == nil
}

var _AnnotationColorValue = map[string]AnnotationColor{
	"annotation_red":   AnnotationRed,
	"annotation_green": AnnotationGreen,
	"annotation_blue":  AnnotationBlue,
}

// ParseAnnotationColor attempts to convert a string to a AnnotationColor.
func ParseAnnotationColor(name string) (AnnotationColor, error) {
	if x, ok := _AnnotationColorValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _AnnotationColorValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return AnnotationColor(""), fmt.Errorf("%s is %w", name, ErrInvalidAnnotationColor)
}

const (
	// AnnotationNumberOne is a AnnotationNumber of type One.
	AnnotationNumberOne AnnotationNumber = iota
	// AnnotationNumberTwo is a AnnotationNumber of type Two.
	AnnotationNumberTwo
	// AnnotationNumberThree is a AnnotationNumber of type Three.
	AnnotationNumberThree
)

var ErrInvalidAnnotationNumber = errors.New("not a valid AnnotationNumber")

const _AnnotationNumberName = "onetwothree"

var _AnnotationNumberMap = map[AnnotationNumber]string{
	AnnotationNumberOne:   _AnnotationNumberName[0:3],
	AnnotationNumberTwo:   _AnnotationNumberName[3:6],
	AnnotationNumberThree: _AnnotationNumberName[6:11],
}

// String implements the Stringer interface.
func (x AnnotationNumber) String() string {
	if str, ok := _AnnotationNumberMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AnnotationNumber(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AnnotationNumber) IsValid() bool {
	_, ok := _AnnotationNumberMap[x]
	return ok
}

var _AnnotationNumberValue = map[string]AnnotationNumber{
	_AnnotationNumberName[0:3]:  AnnotationNumberOne,
	_AnnotationNumberName[3:6]:  AnnotationNumberTwo,
	_AnnotationNumberName[6:11]: AnnotationNumberThree,
}

// ParseAnnotationNumber attempts to convert a string to a AnnotationNumber.
func ParseAnnotationNumber(name string) (AnnotationNumber, error) {
	if x, ok := _AnnotationNumberValue[name]; ok {
		return x, nil
	}
	return AnnotationNumber(0), fmt.Errorf("%s is %w", name, ErrInvalidAnnotationNumber)
}

// MarshalText implements the text marshaller method.
func (x AnnotationNumber) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AnnotationNumber) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAnnotationNumber(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *AnnotationNumber) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

var errAnnotationNumberNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *AnnotationNumber) Scan(value interface{}) (err error) {
	if value == nil {
		*x = AnnotationNumber(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = AnnotationNumber(v)
	case string:
		*x, err = ParseAnnotationNumber(v)
	case []byte:
		*x, err = ParseAnnotationNumber(string(v))
	case AnnotationNumber:
		*x = v
	case int:
		*x = AnnotationNumber(v)
	case *AnnotationNumber:
		if v == nil {
			return errAnnotationNumberNilPtr
		}
		*x = *v
	case uint:
		*x = AnnotationNumber(v)
	case uint64:
		*x = AnnotationNumber(v)
	case *int:
		if v == nil {
			return errAnnotationNumberNilPtr
		}
		*x = AnnotationNumber(*v)
	case *int64:
		if v == nil {
			return errAnnotationNumberNilPtr
		}
		*x = AnnotationNumber(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = AnnotationNumber(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errAnnotationNumberNilPtr
		}
		*x = AnnotationNumber(*v)
	case *uint:
		if v == nil {
			return errAnnotationNumberNilPtr
		}
		*x = AnnotationNumber(*v)
	case *uint64:
		if v == nil {
			return errAnnotationNumberNilPtr
		}
		*x = AnnotationNumber(*v)
	case *string:
		if v == nil {
			return errAnnotationNumberNilPtr
		}
		*x, err = ParseAnnotationNumber(*v)
	}

	return
}

// Value implements the driver Valuer interface.
func (x AnnotationNumber) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// MyAnnotationStatusPending is a AnnotationStatus of type pending.
	MyAnnotationStatusPending AnnotationStatus = "pending"
	// MyAnnotationStatusRunning is a AnnotationStatus of type running.
	MyAnnotationStatusRunning AnnotationStatus = "running"
	// MyAnnotationStatusCompleted is a AnnotationStatus of type completed.
	MyAnnotationStatusCompleted AnnotationStatus = "completed"
	// MyAnnotationStatusFailed is a AnnotationStatus of type failed.
	MyAnnotationStatusFailed AnnotationStatus = "failed"
)

var ErrInvalidAnnotationStatus = errors.New("not a valid AnnotationStatus")

// String implements the Stringer interface.
func (x AnnotationStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AnnotationStatus) IsValid() bool {
	_, err := ParseAnnotationStatus(string(x))
	return err == nil
}

var _AnnotationStatusValue = map[string]AnnotationStatus{
	"pending":   MyAnnotationStatusPending,
	"running":   MyAnnotationStatusRunning,
	"completed": MyAnnotationStatusCompleted,
	"failed":    MyAnnotationStatusFailed,
}

// ParseAnnotationStatus attempts to convert a string to a AnnotationStatus.
func ParseAnnotationStatus(name string) (AnnotationStatus, error) {
	if x, ok := _AnnotationStatusValue[name]; ok {
		return x, nil
	}
	return AnnotationStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidAnnotationStatus)
}

// MarshalText implements the text marshaller method.
func (x AnnotationStatus) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AnnotationStatus) UnmarshalText(text []byte) error {
	tmp, err := ParseAnnotationStatus(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *AnnotationStatus) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
